---
title: "Nest Desertion Script (Following Woodcock codes example-Stephen Oppel) "
author: "Mariem Belkadhi"
date: "2025-10-08"
output: html_document
---



```{r}


library(readxl)

obs <- as.data.frame(
  read_xlsx("data/Observations2023.xlsx", sheet = 1)
)
head(obs)

```

# Whiskered Tern brood desertion / departure model (NIMBLE) 
# 3 latent states: 1=two parents present, 2=one parent present, 3=zero parents
# Observations O are 1,2,3 (observed: 2,1,0 parents) with small misclassification

```{r}
## Libraries
if(!requireNamespace("nimble", quietly=TRUE)) install.packages("nimble")
pkgs <- c("lubridate","tidyverse","data.table","MCMCvis","coda","ggplot2")
for(p in pkgs) if(!requireNamespace(p, quietly=TRUE)) install.packages(p)
library(lubridate)
library(tidyverse)
library(data.table)
library(MCMCvis)
library(coda)
library(nimble)

set.seed(2025)
```


## Input checks

```{r}

if("NEST ID" %in% names(obs)) obs$NestID <- as.character(obs[["NEST ID"]])
if("NEST_ID" %in% names(obs)) obs$NestID <- as.character(obs[["NEST_ID"]])
if(!("NestID" %in% names(obs))) stop("Column 'NEST ID' (or 'NEST_ID') not found in 'obs'.")
if(!("Parents" %in% names(obs))) stop("Column 'Parents' not found in 'obs'.")
if(!("DATE" %in% names(obs))) stop("Column 'DATE' not found in 'obs'.")

```

## ----- Build encounter matrix y (nind x nweeks) --------------------------
```{r}
obs <- obs %>% mutate(DATE = as.Date(DATE))

survey_dates <- sort(unique(obs$DATE))
nweeks <- length(survey_dates)
nest_ids <- sort(unique(obs$NestID))
nind <- length(nest_ids)

wide <- obs %>% 
  select(NestID, Parents, DATE) %>%
  distinct(NestID, DATE, .keep_all = TRUE) %>%
  mutate(DATE = as.Date(DATE)) %>%
  arrange(NestID, DATE) %>%
  tidyr::pivot_wider(names_from = DATE, values_from = Parents)
```

# Map Parents -> model categories:
# Parents==2 -> 1  ; Parents==1 -> 2 ; Parents==0 -> 3 ; NA -> NA (missing survey)

```{r}
y_mat <- matrix(NA_integer_, nrow = nind, ncol = nweeks,
                dimnames = list(nest_ids, as.character(survey_dates)))
for(i in seq_len(nind)){
  row <- wide[i, -1]
  for(j in seq_len(nweeks)){
    v <- suppressWarnings(as.numeric(row[[j]]))
    if(is.na(v)) {
      y_mat[i,j] <- NA_integer_
    } else if(v >= 2) {
      y_mat[i,j] <- 1L
    } else if(v == 1) {
      y_mat[i,j] <- 2L
    } else { # v==0 or other <=0
      y_mat[i,j] <- 3L
    }
  }
}
```

# First survey index with any observation per nest 
```{r}
f <- integer(nind)
for(i in seq_len(nind)){
  idx <- which(!is.na(y_mat[i,]))
  f[i] <- if(length(idx)==0) 1L else min(idx)
}

isObs <- 1L * (!is.na(y_mat))
effort <- matrix(1, nrow = nind, ncol = nweeks)
# year   <- rep(1L, nind); nyears <- 1L
# tag    <- rep(0L, nind)
```

##  Build *monotone* initial z (no return allowed in TRUE states)
# keeping raw y as data (with NAs), but z inits must obey 1→2→3 monotonicity.
```{r}
z_init <- matrix(NA_integer_, nrow = nind, ncol = nweeks,
                 dimnames = dimnames(y_mat))
mods <- 0L
for(i in seq_len(nind)){
  
  zi <- as.integer(y_mat[i, ])

  obs_pos <- which(!is.na(zi))
  if(length(obs_pos) == 0){
    zi[] <- 1L
  } else {
    first <- obs_pos[1]
   
    if(first > 1) zi[1:(first-1)] <- zi[first]  ## you can leave NA before the first observation because the model ignores anything before the first observation
    
    for(t in (first+1):nweeks){
      if(is.na(zi[t])) {
        y_mat[i,t]<-3 ## intermediate NAs should be set to state 3 (no birds observed) in the observation matrix
        zi[t] <- zi[t-1]}
      if(t<nweeks){
        if(min(zi[(t+1):nweeks], na.rm=T)<zi[t]) {zi[t]<-min(zi[(t+1):nweeks], na.rm=T)}  ## the minimum state (max number of ind) is maintained until the last observation of that state
      }
    }
   
    # zi_fix <- cummax(zi)  ## THIS IS WRONG
    # mods <- mods + sum(zi_fix != zi, na.rm = TRUE)
    # zi <- zi_fix
  }
 
  zi[zi < 1] <- 1L; zi[zi > 3] <- 3L
  z_init[i, ] <- zi
}
cat("Initial z modifications to enforce monotonicity:", mods, "\n")
```

## NIMBLE model: NO RETURN in true states

```{r}
whi.mig.model <- nimbleCode({

  ## Prior parameters (changed to use normal 0 prior on logit scale directly)
  lm.mean ~ dnorm(0, 1)
  b.mig.week ~ dnorm(0, 1)               
  lp.mean ~ dnorm(0, 0.1)
  b.obs.eff ~ dnorm(1, 1)
  # eps <- 1e-6            ## this is a fixed near-zero observation probability that does not make much sense?                    

  
  for (i in 1:nind) {
    for (t in f[i]:nweeks) {
      logit.mig[i,t] <- lm.mean + b.mig.week * week[t]
      mig[i,t] <- ilogit(logit.mig[i,t])
      logit.p.obs[i,t] <- lp.mean + b.obs.eff * isObs[i,t]
      p.obs[i,t] <- ilogit(logit.p.obs[i,t])
    }
  }

  # Transitions & observations (no return in TRUE states)
  for (i in 1:nind) {
    for (t in f[i]:(nweeks-1)) {
      # ---- TRUE state transitions (rows=from, cols=to) ----
      # From 1 (two parents): each parent leaves independently with prob mig
      ps[1,i,t,1] <- (1 - mig[i,t]) * (1 - mig[i,t])            #  2 present
      ps[1,i,t,2] <- mig[i,t] * (1 - mig[i,t])              #  1 present ## SO deleted a 2 *
      ps[1,i,t,3] <- mig[i,t] * mig[i,t]                        #  0 present

      # From 2 (one parent present): that parent may leave; absent parent cannot return
      ps[2,i,t,1] <- 0
      ps[2,i,t,2] <- 1 - mig[i,t]
      ps[2,i,t,3] <- mig[i,t]

      # From 3 (zero present): absorbing (no return)
      ps[3,i,t,1] <- 0
      ps[3,i,t,2] <- 0
      ps[3,i,t,3] <- 1

      # ---- OBSERVATION model (detection error allowed) ----
      # True=1 (two present): Binomial(2, p.obs)
      po[1,i,t,1] <- p.obs[i,t] * p.obs[i,t]                    # observe 2
      po[1,i,t,2] <- p.obs[i,t] * (1 - p.obs[i,t])          # observe 1  ## SO deleted a 2*
      po[1,i,t,3] <- (1 - p.obs[i,t]) * (1 - p.obs[i,t])        # observe 0

      # True=2 (one present): usually observe 1, allow tiny chance to see 2
      po[2,i,t,1] <- 0  ## this should by definition be 0 - you can only know that it is not 0 if birds are individually recognizable? That info is not in this model though!?
      po[2,i,t,2] <- p.obs[i,t]
      po[2,i,t,3] <- 1 - p.obs[i,t]

      # True=3 (zero present): mostly 0; allow tiny misclassification to 1 or 2
      po[3,i,t,1] <- 0
      po[3,i,t,2] <- 0
      po[3,i,t,3] <- 1  ## if nobody is at the nest then no bird can be observed
    }
  }

  # Masked likelihood for missing surveys:
  #   if isObs=1 -> use po; if isObs=0 -> uniform over {1,2,3}  ## this should be in the observation process
  for (i in 1:nind) {
    # Define latent state at first capture
    z[i,f[i]] <- 1 ## on first record the nest should have had 2 parents - otherwise it is pointless to include it for estimation of nest desertion
    for (t in (f[i]+1):nweeks) {
      # State process - transition probability from one state to the next (migration)
      z[i,t] ~ dcat(ps[z[i,t-1], i, t-1, 1:3])                # state process
      # for (k in 1:3) { ## I am not sure what this will actually achieve?
      #   w[i,t,k] <- isObs[i,t] * po[z[i,t], i, t-1, k] + (1 - isObs[i,t]) * (1/3)
      #   w[i,t,k] <- po[z[i,t], i, t-1, k]
      # }
      # Observation process - probability to observe a number of birds given the true state z[i,t]
      y[i,t] ~ dcat(po[z[i,t], i, t-1, 1:3])                              # observation process
    }
  }
  
})
```


## Data & constants for NIMBLE 

```{r}
whi.constants <- list(f = f,
                      week = seq_len(nweeks),
                      nind = nind,
                      #nyears = 1L,  ## not needed in this model
                      #year = rep(1L, nind),   ## not needed in this model
                      #effort = effort, ## not yet included - should affect p.obs, but only if effort can vary - so far it does not, replaced by isObs
                      #tag = tag, ## not needed in this model
                      isObs = isObs, ## this is effectively a binary matrix of whether a nest was observed or not?
                      nweeks = nweeks)

whi.data <- list(y = y_mat)

whi.dims <- list(ps = c(3, nind, nweeks, 3),
                 po = c(3, nind, nweeks, 3))
```

## Inits & parameters 

```{r}
parameters <- c("lm.mean", "b.mig.week", "lp.mean","b.obs.eff")

smartInit <- list(
  z = z_init,
  lm.mean = 0.1,
  b.mig.week = 0.1,
  b.obs.eff = 1.5,
  lp.mean = 0
)
```

## MCMC settings

```{r}
n.iter   <- 20000
n.burnin <- 10000
n.chains <- 3
thin     <- 2


# PRELIMINARY TEST OF NIMBLE MODEL TO IDENTIFY PROBLEMS --------------------
test <- nimbleModel(code = whi.mig.model,
                       constants = whi.constants,
                       data = whi.data,
                       inits = smartInit,
                    calculate=TRUE)

### make sure that none of the logProbs result in NA or -Inf as the model will not converge
test$calculate()  # will sum all log probs - if there is -Inf or NA then something is not properly initialised
test$initializeInfo()

# use test output as starting values or check where the NA comes from
test$logProb_b.mig.week
test$logProb_b.obs.eff
test$logProb_y ### there should not be any -Inf in this matrix
y_mat[2,6:12]
z_init[2,6:12]
isObs[2,6:12]



tic <- function() assign(".timer", proc.time(), envir=.GlobalEnv)
toc <- function() print((proc.time()-get(".timer", envir=.GlobalEnv))["elapsed"])
tic()
whi_mcmc <- nimbleMCMC(code = whi.mig.model,
                       constants = whi.constants,
                       data = whi.data,
                       inits = smartInit,
                       dimensions = whi.dims,
                       monitors = parameters,
                       thin = thin,
                       niter = n.iter,
                       nburnin = n.burnin,
                       nchains = n.chains,
                       summary = TRUE)
toc()

if(!dir.exists("output")) dir.create("output", showWarnings = FALSE)
print(whi_mcmc$summary)
```

## Posterior: weekly desertion probability 

```{r}
MCMCout  <- do.call(rbind, whi_mcmc$samples)
parmcols <- colnames(MCMCout)
nSamps   <- nrow(MCMCout)
weeks    <- seq_len(nweeks)

lm_vec <- as.numeric(MCMCout[, "lm.mean"])
bmig_vec    <- as.numeric(MCMCout[, "b.mig.week"])

Wmat          <- matrix(weeks, nrow = nSamps, ncol = nweeks, byrow = TRUE)
logit_mig_mat <- matrix(lm_vec, nSamps, nweeks) + matrix(bmig_vec, nSamps, nweeks) * Wmat
mig_mat       <- plogis(logit_mig_mat)

mig_summary <- data.frame(
  week = weeks,
  mig_median = apply(mig_mat, 2, median),
  mig_lcl    = apply(mig_mat, 2, quantile, 0.025),
  mig_ucl    = apply(mig_mat, 2, quantile, 0.975),
  Date       = survey_dates
)

 ggplot(mig_summary, aes(x = Date)) +
  geom_ribbon(aes(ymin = mig_lcl, ymax = mig_ucl), alpha = 0.20, fill = "firebrick") +
  geom_line(aes(y = mig_median), linewidth = 1, color = "firebrick") +
  scale_y_continuous("Weekly prob. one parent leaves", limits = c(0,1)) +
  scale_x_date("Survey date") +
  theme_minimal()
```

## Simulate cumulative proportion deserted (pop = 1000) 


```{r}

pop0 <- 1000
left_mat    <- matrix(0L, nrow = nSamps, ncol = nweeks)
pop_remain  <- matrix(pop0, nrow = nSamps, ncol = nweeks)
for(w in 1:nweeks){
  probs  <- mig_mat[, w]
  left_w <- rbinom(nSamps, pop_remain[, w], probs)
  left_mat[, w] <- left_w
  if(w < nweeks) pop_remain[, w+1] <- pop_remain[, w] - left_w
}
prop_mig_mat <- t(apply(left_mat, 1, cumsum)) / pop0
prop_summary <- data.frame(
  week    = weeks,
  prop_med= apply(prop_mig_mat, 2, median),
  prop_lcl= apply(prop_mig_mat, 2, quantile, 0.025),
  prop_ucl= apply(prop_mig_mat, 2, quantile, 0.975),
  Date    = survey_dates
)

ggplot(prop_summary, aes(x = Date)) +
  geom_ribbon(aes(ymin = prop_lcl, ymax = prop_ucl), alpha = 0.20, fill = "firebrick") +
  geom_line(aes(y = prop_med), linewidth = 1, color = "firebrick") +
  scale_y_continuous("Cumulative proportion nests deserted (sim.)", limits = c(0,1)) +
  scale_x_date("Survey date") +
  theme_minimal()




```

# R-hat and ESS


```{r}

library(MCMCvis)
MCMCsummary(whi_mcmc$samples, params = c("lm.mean", "b.mig.week", "lp.mean","b.obs.eff"))
MCMCplot(whi_mcmc$samples, params = c("lm.mean", "b.mig.week", "lp.mean","b.obs.eff"))

```


